# Thanos Architecture

![](../images/thanosarchitecture.jpg)

Khi `grafana` truy vấn các metric của prometheus, các yêu cầu được chuyển đến `thanos querier`. `Thanos querier` chịu trách nhiệm đưa ra các truy vấn này cho các thành phần `StoreAPI`. StoreAPI cũng có trên các thành phần như `Rulers`, `Sidecars`, `Store Gateways`.

Yêu cầu sẽ được chuyển tới `Thanos Sidecar` để lấy dữ liệu trong khoảng thời gian và nhãn được chỉ định. Thanos Sidecar luôn đi kèm với prometheus, nó đọc và lưu trữ dữ liệu của prometheus trên 1 object storage. Khi prometheus ghi dữ liệu vào TSDB, `sidecar StoreAPI` sẽ phát hiện dữ liệu đó và tải chúng lên `object storage`. Store cũng hoạt động như 1 thành phần proxy, cho phép `querier` nói chuyện với nó để tìm nạp dữ liệu.

`Thanos compactor` là 1 thành phần thiết yếu, nó áp dụng các thủ tục nén của prometheus 2.0 để lưu giữ các block trong các `object storage`. 

`Thanos rule` chịu trách nhiệm giám sát, nó là một công cụ hữu ích để đánh giá các cảnh báo, nó thực hiện đánh giá các metric dựa trên các rule và đưa ra cảnh báo gửi về alertmanager.

### Cách thực thi truy vấn xảy ra trong thanos ?

Trong thanos, công cụ vanilla PromQL được sử dụng để đánh giá truy vấn để tìm ra time seri nào và phạm vi thời gian nào chúng ta cần để tìm nạp dữ liệu. Thanos sử dụng tính năng lọc cơ bản dựa trên phạm vi thời gian và label để lọc ra các StoreAPI sẽ không cung cấp cho nó dữ liệu mà nó mong muốn và sau đó gọi những dữ liệu còn lại.

Các kết quả sau đó được hợp nhất và nối lại với nhau theo thười gian từ các nguồn khác nhau. 

### Cách thanos xác định máy chủ API nào có dữ liệu mà nó cần trong một truy vấn ?

StoreAPI truyền bá các label và các phạm vi thời gian mà nó đang có dữ liệu. Vì vậy có thể thực hiện việc lọc cơ bản dựa vào những điều này. Ngoài ra có thể có một số kêt quả trùng lặp giữa các dữ liệu ở sidecar và các dữ liệu store data, điều này khó tránh.


### Liệu có vấn đề với nhiều sidecar cố gắng tải các block dữ liệu giống nhau lên object storage không ?

Có các lable duy nhất cho tất cả các phiên bản `Prometheus` `+` `sidecar` khác nhau. Để chỉ ra rằng tất cả các bản sao đang lưu trữ các mục tiêu giống nhau, chúng chỉ khác nhau ở 1 một nhãn. Ví dụ:

```
One:

"cluster": "prod1"
"replica": "0"
```

```
Two:

"cluster":"prod1"
"replica": "1"
```

Không có vấn đề với việc lưu trữ các metric có các nhãn trên vì các bộ nhãn là duy nhất. Querier có khả năng khử các trùng lặp metric bằng nhãn `replica` một cách nhanh chóng.





